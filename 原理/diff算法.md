# diff算法

diff 是对比的意思

Diff 算法是一种对比算法。对比两者是 旧虚拟 DOM 和新虚拟 DOM，对比出是哪个 虚拟节点更改了，找出这个 虚拟节点并只更新这个虚拟节点所对应的 真实节点而不用更新其他数据没发生改变的节点，实现 精准地更新真实 DOM，进而 提高效率

在新老虚拟 DOM 对比时：

首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换

如果为相同节点，进行 patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)

比较如果都有子节点，则进行 updateChildren，判断如何对这些新老节点的子节点进行操作（diff 核心）。

匹配时，找到相同的子节点，递归比较子节点

在 diff 中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从 O(n3)降低值 O(n)，也就是说，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。

`diff`整体策略为：深度优先，同层比较

1. 比较只会在同层级进行, 不会跨层级比较
2. 比较的过程中，循环从两边向中间收拢

# vue2

vue 的`diff` 算法用来找出两颗虚拟 dom 树的不同。它的特点：

- 比较只会在同层级进行, 不会跨层级比较
- tag 不相同，则直接删掉重建，不再深度比较
- tag 和 key，两者都相同，表示相同节点，不再深度比较

当数据发生改变时，`set`方法会调用`Dep.notify`通知所有订阅者`Watcher`，订阅者就会调用`patch`给真实的`DOM`打补丁，更新相应的视图

## path函数大致逻辑：

没有新节点，直接触发旧节点的destory钩子

没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm

旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode去处理这两个节点

旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点

## 小结：

当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁

通过isSameVnode进行判断，相同则调用patchVnode方法

### patchVnode

做了以下操作：

找到对应的真实dom，称为el

如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点

如果oldVnode有子节点而VNode没有，则删除el子节点

如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el

如果两者都有子节点，则执行updateChildren函数比较子节点

### updateChildren

主要做了以下操作：

设置新旧VNode的头尾指针

新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作

# vue3

底层的diff算法改成了快速Diff

更新时并不会对所有的节点都进行`diff`更新，

在真正进入Diff之前，快速Diff会先执行一段”预处理“的前置操作。目的是先把可以直接排除的项去掉，降低diff的操作量。这个思路来自与unix等操作系统的文件内容diff

预处理本质上是为了”对齐“，diff是一个繁琐的过程，涉及到新增，删除，改顺序，替换等操作。但无论是什么操作，最后新旧两组节点应该都要长度一样。即如果新比旧长，就要把新的多出部分新增补齐，如果是旧比新长，就要把旧的多出部分删除对齐。

目前会进行`diff`更新的有以下两种情况：

- `v-for`容器节点
- 自写的`render()`函数

`diff`更新调用的内部的`patchKeyedChildren`方法，其大致流程分为三步：

1. 对比新旧节点头部相同指针的节点，相同则进行`diff`，不同则跳转下一步。
2. 对比新旧节点尾部指针指向节点，相同则进行`diff`，不同则跳转下一步。
3. 此时剩余新旧节点，可能存在乱序、已移除或新增的情况，进行特殊处理来更新。

