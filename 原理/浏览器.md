# 1.对于http1.1协议，相同域不同接口同时只能并行6个，超出的部分会被挂起，

## 方法：

1.升级为http2.0

2.让请求处于不同域

域由三个部分构成： 协议+主机名+端口，只要一个不同，域就不同。

## 为何要限制并发请求数：

###### 1.对操作系统端口资源考虑

PC总端口数为65536，那么一个TCP（http也是tcp）链接就占用一个端口。操作系统通常会对总端口一半开放对外请求，以防端口数量不被迅速消耗殆尽。

###### 2.过多并发导致频繁切换产生性能问题

一个线程对应处理一个http请求，那么如果并发数量巨大的话会导致线程频繁切换。而线程的上下文切换有时候并不是轻量级的资源。这导致得不偿失，所以请求控制器里面会产生一个链接池，以复用之前的链接。所以我们可以看作同域名下链接池最大为4～8个，如果链接池全部被使用会阻塞后面请求任务，等待有空闲链接时执行后续任务。

###### 3.避免同一客服端并发大量请求超过服务端的并发阈值

在服务端通常都对同一个客户端来源设置并发阀值避免恶意攻击，如果浏览器不对同一域名做并发限制可能会导致超过服务端的并发阀值被BAN掉。

###### 4.客户端良知机制

为了防止两个应用抢占资源时候导致强势一方无限制的获取资源导致弱势一方永远阻塞状态

并发调用是通过浏览器建立的并发连接通道来实现的。每一个连接都需要从服务器分配一些资源。此外，服务器必须维护每一个来自于客户端的连接请求的信息。此外，DOS 攻击的可能性很高。因此，服务端限制了来自于客户端的连接数量。

## http2.0为何没有限制

http1.x 存在性能问题：
\1. header 不会被压缩；
\2. http 报文段之间的 header十分相似，但是在重复进行传输;
\3. 无法复用，同一个服务器打开多个链接时，能复用的 tcp 效率远胜于重新建立连接。

因此，http 2 引入了帧的概念，将数据和报头分离，即减少了大量 tcp 数据包里面是 http 报文头的 tcp 报文。连续的多个 http1 的报文被拆分为报头和数据两部分，提取公共报头作为 http2 的数据帧，http1 的数据也被作为后续的数据帧处理，多帧进行发送，整个过程被称为**多路复用**

[HTTP/2 帧机制是在 HTTP/1.x 语法和底层传输协议之间增加了一个新的中间层，而没有从根本上修改它，即它是建立在经过验证的机制之上。](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages)

因此，http 2 并不是一种新的底层协议，而是一个降低传输冗余的中间协议，因此，浏览器的并发限制，并不需要特定对 http 2做出说明。

## http1.1的并发

层级不一样。HTTP 应用层，TCP 是传输层。

HTTP/1.0 里，每一次 HTTP 请求，就要建立一个 TCP 链接。而 TCP 的建立开销很大。

为了解决这个问题，HTTP/1.1 引入了 Keep-Alive，可以一个 TCP 链接上发送多个 HTTP 请求，但这个协议模型本身还是在 HTTP/1.0 上修修补补，缺点还是有的，也就是同一个 TCP 链接上，多个 HTTP 请求彼此间是阻塞的，也就是请求 A 先得到响应后，请求 B 才会开始发送。

那能不能一个 TCP 链接既可以发送多个 HTTP 请求、每个 HTTP 请求之间彼此还不阻塞呢？HTTP/2.0 应用而生，引入 Stream，解决了这个问题。

HTTP 的并发限制，是浏览器做的（防止一个网页引入了巨多的资源、全都同时开启下载导致系统资源被迅速耗尽），如果不是浏览器、自己写 HTTP 客户端，是没这个限制的。

HTTP/1.1 的所谓并发是浏览器干的，是多个 TCP 并发，但每个 TCP 里的 HTTP 还是阻塞的。

HTTP/2.0 里除了 TCP 并发外，每个 TCP 里的 HTTP 里也是并发的。